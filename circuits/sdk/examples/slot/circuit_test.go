package slot

import (
	"context"
	"fmt"
	"github.com/consensys/gnark/backend"
	"github.com/consensys/gnark/test"
	"os"
	"testing"

	"github.com/celer-network/brevis-sdk/circuits/sdk/sdk"
	"github.com/celer-network/brevis-sdk/circuits/sdk/sdk/srs"
	"github.com/celer-network/brevis-sdk/common/utils"
	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/backend/plonk"
	cs "github.com/consensys/gnark/constraint/bls12-377"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/frontend/cs/scs"
	replonk "github.com/consensys/gnark/std/recursion/plonk"
	"github.com/ethereum/go-ethereum/common"
)

func TestCircuit(t *testing.T) {
	q, err := sdk.NewQuerier("") // TODO use your eth rpc
	check(err)

	account := common.HexToAddress("0x5427FEFA711Eff984124bFBB1AB6fbf5E3DA1820")
	blockNum := 18233760
	q.AddStorageSlot(sdk.StorageSlotQuery{
		BlockNum: blockNum,
		Address:  account,
		Slot:     common.BytesToHash(slot),
	})
	// More slots can be added to be batch proven, but in this example we use only
	// one to keep it simple
	// q.AddStorageSlot(...)
	// q.AddStorageSlot(...)
	// q.AddStorageSlot(...)

	guest := &GuestCircuit{}
	guestAssignment := &GuestCircuit{}

	w, _, err := q.BuildWitness(context.Background(), guest)
	check(err)

	host := sdk.NewHostCircuit(w, guest)
	assignment := sdk.NewHostCircuit(w.Clone(), guestAssignment)

	///////////////////////////////////////////////////////////////////////////////
	// Testing
	///////////////////////////////////////////////////////////////////////////////

	// Use gnark's test package to check if the circuit can be solved using the
	// given assignment
	assert := test.NewAssert(t)
	assert.ProverSucceeded(host, assignment, test.WithBackends(backend.PLONK), test.WithCurves(ecc.BLS12_377))

	///////////////////////////////////////////////////////////////////////////////
	// Compiling and Setup
	///////////////////////////////////////////////////////////////////////////////

	// The compilation output is the description of the circuit's constraint system.
	// You should use ccs.WriteTo to serialize and save your circuit so that it can
	// be used in the proving step later.
	ccs, err := frontend.Compile(ecc.BLS12_377.ScalarField(), scs.NewBuilder, host)
	check(err)

	fmt.Println(">> new srs")
	r1cs := ccs.(*cs.SparseR1CS)
	srsDir := os.ExpandEnv("$HOME/kzgsrs")
	// SRS (structured reference string) is used in the KZG commitment scheme. You
	// must download the Brevis provided SRS in your setup. The SRS files can get
	// pretty big (gigabytes), the srs package allows you to specify a dir for
	// caching the downloaded files.
	canonical, lagrange, err := srs.NewSRS(r1cs, "https://kzg-srs.s3.us-west-2.amazonaws.com", srsDir)
	check(err)
	fmt.Println("constraints", r1cs.GetNbConstraints())

	fmt.Println(">> generate witness")
	witnessFull, err := frontend.NewWitness(assignment, ecc.BLS12_377.ScalarField())
	check(err)

	witnessPublic, err := witnessFull.Public()
	check(err)
	utils.WriteWitness("slot_witness_pub", witnessPublic)

	fmt.Println(">> setup")
	// Setup is a one-time effort per circuit. You should use pk/vk.WriteTo to
	// serialize and save the proving/verifying keys to disk for later use.
	pk, vk, err := plonk.Setup(ccs, canonical, lagrange)
	check(err)
	utils.WritePlonkVerifyingKey(vk, "slot_vk")

	// Once you have the verifying key you should also save its hash in your contract
	// so that when a proof via Brevis is submitted on-chain you can verify that
	// Brevis indeed used your verifying key to verify your circuit computations
	vkHash, err := sdk.VkHash(vk)
	check(err)
	fmt.Printf("verifying key hash: %x\n", vkHash)
	// myContract.SetVKHash(vkHash)

	///////////////////////////////////////////////////////////////////////////////
	// Proving
	///////////////////////////////////////////////////////////////////////////////

	fmt.Println(">> prove")
	// pk can also be read from disk using pk.ReadFrom
	proof, err := plonk.Prove(ccs, pk, witnessFull, replonk.GetNativeProverOptions(ecc.BW6_761.ScalarField(), ecc.BLS12_377.ScalarField()))
	check(err)
	err = utils.WritePlonkProofIntoLocalFile(proof, "slot_proof")
	check(err)

	///////////////////////////////////////////////////////////////////////////////
	// Verifying
	///////////////////////////////////////////////////////////////////////////////

	// The verification of the proof generated by you is done on Brevis' side. But
	// you can also verify your own proof to make sure everything works fine and
	// pk/vk are serialized/deserialized properly
	fmt.Println(">> verify")
	err = plonk.Verify(proof, vk, witnessPublic, replonk.GetNativeVerifierOptions(ecc.BW6_761.ScalarField(), ecc.BLS12_377.ScalarField()))
	check(err)
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}
