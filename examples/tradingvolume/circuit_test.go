package tradingvolume

import (
	"context"
	"fmt"
	"github.com/celer-network/brevis-sdk/sdk"
	"github.com/celer-network/brevis-sdk/test"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/stretchr/testify/require"
	"testing"
)

// In this example, we want to analyze the `Swap` events emitted by Uniswap's
// UniversalRouter contract. Let's declare the fields we want to use:

func TestCircuit(t *testing.T) {
	q, err := sdk.NewQuerier("https://eth-mainnet.nodereal.io/v1/0af795b55d124a61b86836461ece1dee") // TODO use your eth rpc
	check(err)

	// Adding a receipt query into the querier
	// In this tx, the user sold USDC and took native ETH out
	q.AddReceipt(sdk.ReceiptQuery{
		TxHash: common.HexToHash("53b37ec7975d217295f4bdadf8043b261fc49dccc16da9b9fc8b9530845a5794"),
		SubQueries: [3]sdk.LogFieldQuery{
			{LogIndex: 3, IsTopic: false, FieldIndex: 0}, // field: USDCPool.Swap.amount0
			{LogIndex: 3, IsTopic: true, FieldIndex: 2},  // field: USDCPool.Swap.recipient (topic field)
			{LogIndex: 2, IsTopic: true, FieldIndex: 1},  // field: USDC.Transfer.from
		},
	})
	// More receipts can be added, but in this example we only add one to keep it simple
	// q.AddReceipt(...)
	// q.AddReceipt(...)

	// Initialize our GuestCircuit and prepare the circuit assignment
	guest := &GuestCircuit{
		UserAddr: sdk.ParseAddress(common.HexToAddress("0xaefB31e9EEee2822f4C1cBC13B70948b0B5C0b3c")),
	}
	guestAssignment := &GuestCircuit{
		UserAddr: sdk.ParseAddress(common.HexToAddress("0xaefB31e9EEee2822f4C1cBC13B70948b0B5C0b3c")),
	}

	// Execute the added queries and package the query results into circuit inputs (witness)
	in, output, err := q.BuildCircuitInput(context.Background(), guest)
	check(err)

	// `output` is the abi encoded data that we added through api.OutputXXX() in the guest circuit.
	// We want to use this later to call Brevis gateway so that when brevis submits the proof on-chain,
	// we can directly get our output data in the contract callback.
	// The following two lines aren't necessary, but let's check and see how it's related to
	// `CircuitInput.OutputCommitment`
	fmt.Printf("output added through api.OutputXXX: %x\n", output)
	hashed := common.BytesToHash(crypto.Keccak256(output))
	fmt.Printf("output commitment: %x\n", output)
	require.Equal(t, in.OutputCommitment.Hash(), hashed)

	///////////////////////////////////////////////////////////////////////////////
	// Testing
	///////////////////////////////////////////////////////////////////////////////

	// Use the test package to check if the circuit can be solved using the given
	// assignment
	fmt.Printf("guest %+v\n", guest)
	fmt.Printf("guestAssignment %+v\n", guestAssignment)
	test.ProverSucceeded(t, guest, guestAssignment, in.Clone())

	///////////////////////////////////////////////////////////////////////////////
	// Compiling and Setup
	///////////////////////////////////////////////////////////////////////////////

	// The compilation output is the description of the circuit's constraint system.
	// You should use sdk.WriteTo to serialize and save your circuit so that it can
	// be used in the proving step later.
	ccs, err := sdk.Compile(guest, in)
	check(err)
	err = sdk.WriteTo(ccs, "$HOME/circuitOut/tradingvolume/ccs")
	check(err)

	// Setup is a one-time effort per circuit. A cache dir can be provided to output
	// external dependencies. Once you have the verifying key you should also save
	// its hash in your contract so that when a proof via Brevis is submitted
	// on-chain you can verify that Brevis indeed used your verifying key to verify
	// your circuit computations
	pk, vk, err := sdk.Setup(ccs, "$HOME/circuitOut/tradingvolume")
	check(err)
	err = sdk.WriteTo(pk, "$HOME/circuitOut/tradingvolume/pk")
	check(err)
	err = sdk.WriteTo(vk, "$HOME/circuitOut/tradingvolume/vk")
	check(err)

	// Once you saved your ccs, pk, and vk files, you can read them back into memory
	// for use with the provided utils
	//cs, err = sdk.Rea
	//pk, err = sdk.ReadPkFrom("$HOME/circuitOut/tradingvolume/pk")
	//check(err)
	//vk, err = sdk.ReadVkFrom("$HOME/circuitOut/tradingvolume/vk")
	//check(err)

	///////////////////////////////////////////////////////////////////////////////
	// Proving
	///////////////////////////////////////////////////////////////////////////////

	fmt.Println(">> prove")
	witness, publicWitness, err := sdk.NewFullWitness(guestAssignment, in)
	check(err)

	proof, err := sdk.Prove(ccs, pk, witness)
	check(err)

	///////////////////////////////////////////////////////////////////////////////
	// Verifying
	///////////////////////////////////////////////////////////////////////////////

	// The verification of the proof generated by you is done on Brevis' side. But
	// you can also verify your own proof to make sure everything works fine and
	// pk/vk are serialized/deserialized properly
	err = sdk.Verify(vk, publicWitness, proof)
	check(err)
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}
